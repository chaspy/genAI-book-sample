# 5.5 ハイブリッド検索を実装する

ここまででベクトル検索による RAG が実現できました。次に先ほど学んだハイブリッド検索を実装しましょう。

## 5.5.1 EnsembleRetriever で統合する

実際にハイブリッド検索を実装してみましょう。LangChain の EnsembleRetriever（アンサンブルレトリーバー）を使えば、RRF（スコアリング）の計算も自動でやってくれます。プログラムは `scripts/chapter5/5-5-1-hybrid-search-rrf.py` を参照してください（サンプル文書は `scripts/chapter5/hybrid_sample_data/*.txt` を使用）。

### ソースコード（抜粋）

以下は `scripts/chapter5/5-5-1-hybrid-search-rrf.py` の主要部分のみを抜粋しています（インポートや .env 読み込み、結果保存などは省略）。全文はスクリプトを参照してください。

```python
def tokenize_for_bm25(text: str) -> list[str]:
    """日本語を含むテキストを軽量にトークナイズ（漢字・かなはbi-gram）。"""
    tokens = []
    for chunk in re.findall(r"[A-Za-z0-9]+|[一-龥ぁ-んァ-ンー]+", text):
        if re.fullmatch(r"[A-Za-z0-9]+", chunk):
            tokens.append(chunk)
        elif len(chunk) == 1:
            tokens.append(chunk)
        else:
            tokens.extend(chunk[i : i + 2] for i in range(len(chunk) - 1))
    return tokens

# サンプル文書の読み込みと分割（hybrid_sample_data/*.txt）
docs = […]  # Documentのリストを作成
splits = RecursiveCharacterTextSplitter(
    chunk_size=800, chunk_overlap=160
).split_documents(docs)

# BM25（キーワード検索）
bm25_retriever = BM25Retriever.from_documents(
    splits,
    preprocess_func=tokenize_for_bm25,
)
bm25_retriever.k = 8

# ベクトル検索
vectorstore = Chroma.from_documents(
    documents=splits,
    embedding=OpenAIEmbeddings(),
    collection_name="hybrid_demo",
)
dense_retriever = vectorstore.as_retriever(search_kwargs={"k": 8})

# EnsembleRetrieverでRRF融合
hybrid_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, dense_retriever],
    weights=[0.6, 1.0],
    c=60,
)

query = "Elasticsearchの監視設定"
results = hybrid_retriever.invoke(query)
for i, doc in enumerate(results[:4]):
    title = doc.page_content.splitlines()[0]
    print(f"結果{i+1}: {doc.metadata.get('source')}: {title}")
```

EnsembleRetriever はそのまま LCEL パイプライン（「4 章 4.3.4Chain」参照）の Retriever として使用できるため、既存の RAG システムに簡単に組み込むことができます。

## 5.5.2 検索結果を比較分析する

まず、それぞれの検索手法の比較結果を見てみましょう。

**クエリ：『Elasticsearch の監視設定』**

=== 検索手法の比較 ===

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装  
   「Elasticsearch」「監視」「設定」がそのままヒットして 1 位を獲得。
2. hybrid_doc_01.txt：BM25 アルゴリズムの実装詳細
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

ベクトル検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_03.txt：検索技術の進化と意味理解の革命

「Elasticsearch の監視設定」のように固有名詞を含む具体的な質問では、BM25 が強みを発揮します。ベクトル検索でも 1 位は同じく hybrid_doc_02（Elasticsearch 文書）が返りますが、2〜3 位に文脈が近い一般論（開発生産性や検索技術の概論）が混ざりやすく、下位順位の傾向が BM25 と異なる点に注目してください。

**クエリ：『埋め込み検索のメリット』**

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
3. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中

ベクトル検索結果

1. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
2. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

「埋め込み検索のメリット」は抽象度が高く、意味ベースのマッチが必要になるため、ベクトル検索では embedding の解説を含む hybrid_doc_03 が 1 位に浮上します。一方 BM25 は「検索」など頻出語に引かれて Elasticsearch 実装記事（hybrid_doc_02）を 1 位に置きやすい――キーワードマッチ特有の挙動です。  
→ 1 位: hybrid_doc_03（ベクトル検索）… Dense retrieval と意味検索の利点を解説  
→ 1 位: hybrid_doc_02（BM25）… Elasticsearch 実装で固有名詞・頻出語が強く当たるため

**クエリ：『RAG を最適化するには Dense Retrieval をどう使う？』**

BM25 検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装

ベクトル検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_06.txt：LangChain の EnsembleRetriever による統合検索

「RAG を最適化するには Dense Retrieval をどう使う？」という複合的な質問では、BM25/ベクトルともに RAG 最適化と Dense Retrieval を直接論じる hybrid_doc_05 が 1 位となり、次に Dense retrieval の意義を概説する hybrid_doc_03 が続きます。ベクトル検索では RRF や weights 調整を説明する hybrid_doc_06 が 3 位に入り、複数 Retriever 統合という問いの副次要素をうまく捉えています。

では EnsembleRetriever でこれらを統合した結果を見てみましょう。

=== EnsembleRetriever（ハイブリッド検索）のデモ（実行結果） ===

クエリ：『Elasticsearch の監視設定』

ハイブリッド検索結果（上位 4 件）:

1. hybrid_doc_02.txt: Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt: 開発者の生産性向上と創造的業務への集中
3. hybrid_doc_01.txt: BM25 アルゴリズムの実装詳細
4. hybrid_doc_03.txt: 検索技術の進化と意味理解の革命

クエリ：『埋め込み検索のメリット』

ハイブリッド検索結果（上位 4 件）:

1. hybrid_doc_02.txt: Elasticsearch による高性能検索システムの実装
2. hybrid_doc_03.txt: 検索技術の進化と意味理解の革命
3. hybrid_doc_05.txt: RAG システムの最適化手法と実装戦略
4. hybrid_doc_04.txt: 開発者の生産性向上と創造的業務への集中

両方の検索手法で上位にランクされた文書が、RRF によって総合的に高いスコアを得ています。これが「それぞれの意見を聞く」ハイブリッド検索の強みです。

## コラム：BM25 検索を日本語で扱う Tips

LangChain の BM25Retriever は標準だと `text.split()` で語を切り出すため、日本語のように空白が入らない文章ではうまく動きません。そこでサンプルコードでは正規表現ベースの軽量トークナイザ (`tokenize_for_bm25`) を用意し、`BM25Retriever.from_documents(..., preprocess_func=...)` に渡しています。

この 1 行を挟むだけで、文書とクエリの両方が同じルールで前処理され、「Elasticsearch の監視設定」のような固有名詞クエリでも BM25 が機能します。より精度を高めたい場合は、`tokenize_for_bm25` の中身を MeCab や SudachiPy を使った関数に差し替えることもできます。

## 5.5.3 重み付けパラメータを調整する

さらに興味深いのは、重み付け（weights）を変えることでの動作の変化です。再び「RAG を最適化するには Dense Retrieval をどう使う？」というクエリで見ていきましょう。

=== 重み付けの影響の確認 ===  
クエリ：「RAG を最適化するには Dense Retrieval をどう使う？」

上位 3 件の結果：

設定: BM25 重視（極端） (BM25=2.0, Vector=0.2)

1. hybrid_doc_05.txt
2. hybrid_doc_03.txt
3. hybrid_doc_02.txt

設定: 均等 (BM25=1.0, Vector=1.0)

1. hybrid_doc_05.txt
2. hybrid_doc_03.txt
3. hybrid_doc_02.txt

設定: ベクトル重視（極端） (BM25=0.2, Vector=2.0)

1. hybrid_doc_05.txt
2. hybrid_doc_03.txt
3. hybrid_doc_06.txt

どの設定でも 1 位は `hybrid_doc_05`（RAG 最適化と Dense Retrieval を直接解説）で不動ですが、3 位が `02`（Elasticsearch 実装）から `06`（EnsembleRetriever 解説）に入れ替わるのはベクトル重視ならでは。ベースは同じ RRF でも、weights を振るだけで「実装寄りを拾う」「統合アルゴリズムを拾う」といったニュアンスを調整できるのがポイントです。

## 5.5.4 実装のポイント

- 用途に応じた重み調整：技術文書なら BM25 を重視、FAQ ならベクトル検索を重視など、データの性質に応じて weights パラメータを調整することが重要です。
- RRF の k パラメータ：デフォルトの 60 は多くの場合うまく機能しますが、検索結果の数が少ない場合は調整が必要かもしれません。
- 検索数の設定：各 Retriever の top_k パラメータ（取得数）は最終的に必要な数より多めに設定し、RRF で統合後に絞り込むのが効果的です。

これで、キーワード検索の精度とベクトル検索の柔軟性を併せ持つ、頑健な RAG システムの検索部分が完成しました。
