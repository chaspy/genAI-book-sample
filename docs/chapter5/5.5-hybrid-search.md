# 5.5 ハイブリッド検索を実装する

ここまででベクトル検索によるRAGが実現できました。次に先ほど学んだハイブリッド検索を実装しましょう。

## 5.5.1 EnsembleRetrieverで統合する

実際にハイブリッド検索を実装してみましょう。LangChain の EnsembleRetriever（アンサンブルレトリーバー）を使えば、RRF（スコアリング）の計算も自動でやってくれます。プログラムは `scripts/chapter5/5-5-1-hybrid-search-rrf.py` を参照してください（サンプル文書は `scripts/chapter5/hybrid_sample_data/*.txt` を使用）。

### ソースコード（抜粋）

以下は `scripts/chapter5/5-5-1-hybrid-search-rrf.py` の主要部分のみを抜粋しています（インポートや .env 読み込み、結果保存などは省略）。全文はスクリプトを参照してください。

```python
def tokenize_for_bm25(text: str) -> list[str]:
    """日本語を含むテキストを軽量にトークナイズ（漢字・かなはbi-gram）。"""
    tokens = []
    for chunk in re.findall(r"[A-Za-z0-9]+|[一-龥ぁ-んァ-ンー]+", text):
        if re.fullmatch(r"[A-Za-z0-9]+", chunk):
            tokens.append(chunk)
        elif len(chunk) == 1:
            tokens.append(chunk)
        else:
            tokens.extend(chunk[i : i + 2] for i in range(len(chunk) - 1))
    return tokens

# サンプル文書の読み込みと分割（hybrid_sample_data/*.txt）
docs = […]  # Documentのリストを作成
splits = RecursiveCharacterTextSplitter(
    chunk_size=800, chunk_overlap=160
).split_documents(docs)

# BM25（キーワード検索）
bm25_retriever = BM25Retriever.from_documents(
    splits,
    preprocess_func=tokenize_for_bm25,
)
bm25_retriever.k = 8

# ベクトル検索
vectorstore = Chroma.from_documents(
    documents=splits,
    embedding=OpenAIEmbeddings(),
    collection_name="hybrid_demo",
)
dense_retriever = vectorstore.as_retriever(search_kwargs={"k": 8})

# EnsembleRetrieverでRRF融合
hybrid_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, dense_retriever],
    weights=[0.6, 1.0],
    c=60,
)

query = "Elasticsearchの監視設定"
results = hybrid_retriever.invoke(query)
for i, doc in enumerate(results[:4]):
    print(f"結果{i+1}: {doc.metadata.get('source')} | {doc.page_content[:80]}...")
```

EnsembleRetriever はそのまま LCEL パイプライン（「4章 4.3.4Chain」参照）の Retriever として使用できるため、既存の RAG システムに簡単に組み込むことができます。

## 5.5.2 検索結果を比較分析する

まず、それぞれの検索手法の比較結果を見てみましょう。

**クエリ：『Elasticsearchの監視設定』**

=== 検索手法の比較 ===

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装  
   「Elasticsearch」「監視」「設定」がそのままヒットして 1 位を獲得。
2. hybrid_doc_01.txt：BM25 アルゴリズムの実装詳細
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

ベクトル検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装  
   「Elasticsearchは分散型のリアルタイム検索・分析エンジンで、Apache Luceneをベ...」
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_03.txt：検索技術の進化と意味理解の革命

「Elasticsearchの監視設定」のように固有名詞を含む具体的な質問では、BM25 が強みを発揮します。ベクトル検索でも 1 位は同じく hybrid_doc_02（Elasticsearch 文書）が返りますが、2〜3 位に文脈が近い一般論（開発生産性や検索技術の概論）が混ざりやすく、下位順位の傾向がBM25と異なる点に注目してください。

**クエリ：『埋め込み検索のメリット』**

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearchによる高性能検索システムの実装  
   「Elasticsearchは分散型のリアルタイム検索・分析エンジンで、Apache Luceneをベ...」
2. hybrid_doc_05.txt：RAGシステムの最適化手法と実装戦略  
   「Retrieval-Augmented Generationの性能向上には、複数のアプローチを組み合わせることが効果的で...」
3. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中  
   「適切なツールと手法を組み合わせることで、エンジニアの作業効率は大幅に改善されます。反復的なタスクの自動化により、より価...」

ベクトル検索結果

1. hybrid_doc_03.txt：検索技術の進化と意味理解の革命  
   「従来のキーワードベースの検索から、意味を理解する検索へとパラダイムシフトが起きています。語彙のミスマッチ問題を解決し、ユーザー...」
2. hybrid_doc_02.txt：Elasticsearchによる高性能検索システムの実装  
   「Elasticsearchは分散型のリアルタイム検索・分析エンジンで、Apache Luceneをベ...」
3. hybrid_doc_05.txt：RAGシステムの最適化手法と実装戦略  
   「Retrieval-Augmented Generationの性能向上には、複数のアプローチを組み合わせることが効果的で...」

「埋め込み検索のメリット」は抽象度が高く、意味ベースのマッチが必要になるため、ベクトル検索では embedding の解説を含む hybrid_doc_03 が1位に浮上します。一方BM25は「検索」など頻出語に引かれて Elasticsearch 実装記事（hybrid_doc_02）を1位に置きやすい――キーワードマッチ特有の挙動です。  
→ 1位: hybrid_doc_03（ベクトル検索）…「Dense retrievalの登場により、文書の意味的類似性を高次元ベクトル空間で表現できる」（本文より）
→ 1位: hybrid_doc_02（BM25）…「Elasticsearch…kuromoji tokenizerやMeCabを使用した形態素解析が重要です」（固有名詞ヒットで高スコア）

**クエリ：『RAGを最適化するにはDense Retrievalをどう使う？』**

BM25 検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装

ベクトル検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_06.txt：LangChain の EnsembleRetriever による統合検索

「RAGを最適化するにはDense Retrievalをどう使う？」という複合的な質問では、BM25/ベクトルともに RAG 最適化とDense Retrievalを直接論じる hybrid_doc_05 が1位となり、次にDense retrievalの意義を概説する hybrid_doc_03 が続きます。ベクトル検索ではRRFやweights調整を説明する hybrid_doc_06 が3位に入り、複数Retriever統合という問いの副次要素をうまく捉えています。

=== EnsembleRetriever（ハイブリッド検索）のデモ（実行結果） ===

クエリ：『Elasticsearchの監視設定』

ハイブリッド検索結果（上位4件）:
1. hybrid_doc_02.txt　→ 固有名詞が強いBM25の効果が最大  
   内容：Elasticsearchによる高性能検索システムの実装
2. hybrid_doc_04.txt  
   内容：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_01.txt  
   内容：BM25アルゴリズムの実装詳細
4. hybrid_doc_03.txt  
   内容：検索技術の進化と意味理解の革命

クエリ：『埋め込み検索のメリット』

ハイブリッド検索結果（上位4件）:
1. hybrid_doc_02.txt　→ BM25寄りの要素が残り1位を確保  
   内容：Elasticsearchによる高性能検索システムの実装
2. hybrid_doc_03.txt  
   内容：検索技術の進化と意味理解の革命
3. hybrid_doc_05.txt  
   内容：RAGシステムの最適化手法と実装戦略
4. hybrid_doc_04.txt  
   内容：開発者の生産性向上と創造的業務への集中

※ ハイブリッドはRRFでBM25とベクトルの結果を統合するため、両手法の上位文書が混在する。BM25/ベクトル単体の比較は「Elasticsearchの監視設定」「埋め込み検索のメリット」「RAGを最適化するにはDense Retrievalをどう使う？」の3クエリで確認している。

## コラム：BM25検索を日本語で扱う Tips

LangChain の BM25Retriever は標準だと `text.split()` で語を切り出すため、日本語のように空白が入らない文章ではうまく動きません。そこでサンプルコードでは正規表現ベースの軽量トークナイザ (`tokenize_for_bm25`) を用意し、`BM25Retriever.from_documents(..., preprocess_func=...)` に渡しています。

この 1 行を挟むだけで、文書とクエリの両方が同じルールで前処理され、「Elasticsearchの監視設定」のような固有名詞クエリでも BM25 が機能します。より精度を高めたい場合は、`tokenize_for_bm25` の中身を MeCab や SudachiPy を使った関数に差し替えることもできます。

## 5.5.3 重み付けパラメータを調整する

さらに興味深いのは、重み付け（weights）を変えることでの動作の変化です。「RAGを最適化するにはDense Retrievalをどう使う？」というクエリで見ていきましょう。

=== 重み付けの影響の確認 ===  
クエリ：「RAGを最適化するにはDense Retrievalをどう使う？」

上位3件の結果：

設定: BM25重視 (BM25=1.0, Vector=0.2)  
1. hybrid_doc_05.txt  
2. hybrid_doc_03.txt  
3. hybrid_doc_02.txt

設定: 均等 (BM25=0.5, Vector=0.5)  
1. hybrid_doc_05.txt  
2. hybrid_doc_03.txt  
3. hybrid_doc_02.txt

設定: ベクトル重視 (BM25=0.2, Vector=1.0)  
1. hybrid_doc_05.txt  
2. hybrid_doc_03.txt  
3. hybrid_doc_06.txt

どの設定でも 1 位は `hybrid_doc_05`（RAG最適化とDense Retrievalを直接解説）で不動ですが、3 位が `02`（Elasticsearch実装）から `06`（EnsembleRetriever解説）に入れ替わるのはベクトル重視ならでは。ベースは同じRRFでも、weightsを振るだけで「実装寄りを拾う」「統合アルゴリズムを拾う」といったニュアンスを調整できるのがポイントです。

## 5.5.4 実装のポイント

- 用途に応じた重み調整：技術文書なら BM25 を重視、FAQ ならベクトル検索を重視など、データの性質に応じて weights パラメータを調整することが重要です。
- RRF の k パラメータ：デフォルトの 60 は多くの場合うまく機能しますが、検索結果の数が少ない場合は調整が必要かもしれません。
- 検索数の設定：各 Retriever の top_k パラメータ（取得数）は最終的に必要な数より多めに設定し、RRF で統合後に絞り込むのが効果的です。

これで、キーワード検索の精度とベクトル検索の柔軟性を併せ持つ、頑健な RAG システムの検索部分が完成しました。
