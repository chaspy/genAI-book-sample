# 5.5 ハイブリッド検索を実装する

ここまででベクトル検索によるRAGが実現できました。次に先ほど学んだハイブリッド検索を実装しましょう。

## 5.5.1 EnsembleRetrieverで統合する

実際にハイブリッド検索を実装してみましょう。LangChain の EnsembleRetriever（アンサンブルレトリーバー）を使えば、RRF（スコアリング）の計算も自動でやってくれます。プログラムは `scripts/chapter5/5-5-1-hybrid-search-rrf.py` を参照してください（サンプル文書は `scripts/chapter5/hybrid_sample_data/*.txt` を使用）。

### ソースコード（抜粋）

以下は `scripts/chapter5/5-5-1-hybrid-search-rrf.py` の主要部分のみを抜粋しています（インポートや .env 読み込み、結果保存などは省略）。全文はスクリプトを参照してください。

```python
def tokenize_for_bm25(text: str) -> list[str]:
    """日本語を含むテキストを軽量にトークナイズ（漢字・かなはbi-gram）。"""
    tokens = []
    for chunk in re.findall(r"[A-Za-z0-9]+|[一-龥ぁ-んァ-ンー]+", text):
        if re.fullmatch(r"[A-Za-z0-9]+", chunk):
            tokens.append(chunk)
        elif len(chunk) == 1:
            tokens.append(chunk)
        else:
            tokens.extend(chunk[i : i + 2] for i in range(len(chunk) - 1))
    return tokens

# サンプル文書の読み込みと分割（hybrid_sample_data/*.txt）
docs = […]  # Documentのリストを作成
splits = RecursiveCharacterTextSplitter(
    chunk_size=800, chunk_overlap=160
).split_documents(docs)

# BM25（キーワード検索）
bm25_retriever = BM25Retriever.from_documents(
    splits,
    preprocess_func=tokenize_for_bm25,
)
bm25_retriever.k = 8

# ベクトル検索
vectorstore = Chroma.from_documents(
    documents=splits,
    embedding=OpenAIEmbeddings(),
    collection_name="hybrid_demo",
)
dense_retriever = vectorstore.as_retriever(search_kwargs={"k": 8})

# EnsembleRetrieverでRRF融合
hybrid_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, dense_retriever],
    weights=[0.6, 1.0],
    c=60,
)

query = "Elasticsearchの監視設定"
results = hybrid_retriever.invoke(query)
for i, doc in enumerate(results[:4]):
    print(f"結果{i+1}: {doc.metadata.get('source')} | {doc.page_content[:80]}...")
```

EnsembleRetriever はそのまま LCEL パイプライン（「4章 4.3.4Chain」参照）の Retriever として使用できるため、既存の RAG システムに簡単に組み込むことができます。

## 5.5.2 検索結果を比較分析する

まず、それぞれの検索手法の比較結果を見てみましょう。

**クエリ：『Elasticsearchの監視設定』**

=== 検索手法の比較 ===

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装  
   「日本語検索の場合 kuromoji tokenizer や MeCab を使用した形態素解析が重要です」  
   → 「Elasticsearch」「監視」「設定」など固有名詞が完全一致！
2. hybrid_doc_01.txt：BM25 アルゴリズムの実装解説
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

ベクトル検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装  
   「Elasticsearchは分散型のリアルタイム検索・分析エンジンで、Apache Luceneをベ...」
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_03.txt：検索技術の進化と意味理解の革命

「Elasticsearchの監視設定」のように固有名詞を含む具体的な質問では、BM25 が強みを発揮します。一方ベクトル検索は、固有名詞文書も拾いつつ周辺文脈の近い文書（生産性や検索技術の概論など）も上位に混ざりやすく、順位の傾向が異なることがあります。

**クエリ：『埋め込みベース検索のメリット』**

BM25 検索結果

1. hybrid_doc_03.txt：検索技術の進化と意味理解の革命  
   「語を理解する検索へパラダイムシフトが起きています」
2. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
3. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装

ベクトル検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略  
   「BM25 と Dense Retrieval を統合したハイブリッド検索により...」「埋め込みベース検索のメリットを包括的に説明」
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_06.txt：LangChainのEnsembleRetrieverによる統合検索

「埋め込み検索のメリット」という抽象的な質問では、語の一致だけでは拾いきれないニュアンスをベクトル検索が補完します。

**クエリ：『RAGを最適化するにはDense Retrievalをどう使う？』**

BM25 検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装

ベクトル検索結果

1. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_06.txt：LangChain の EnsembleRetriever による統合検索

=== EnsembleRetriever（ハイブリッド検索） の手元 ===

クエリ：『Elasticsearchの監視設定』

ハイブリッド検索結果（上位4件）:

1. hybrid_doc_02.txt  
   内容：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt  
   内容：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_01.txt  
   内容：BM25アルゴリズムの実装詳細
4. hybrid_doc_03.txt  
   内容：検索技術の進化と意味理解の革命

クエリ：『埋め込み検索のメリット』

ハイブリッド検索結果（上位4件）:

1. hybrid_doc_02.txt  
   内容：Elasticsearchによる高性能検索システムの実装
2. hybrid_doc_03.txt  
   内容：検索技術の進化と意味理解の革命
3. hybrid_doc_05.txt  
   内容：RAGシステムの最適化手法と実装戦略
4. hybrid_doc_04.txt  
   内容：開発者の生産性向上と創造的業務への集中

## コラム：BM25検索を日本語で扱う Tips

LangChain の BM25Retriever は標準だと `text.split()` で語を切り出すため、日本語のように空白が入らない文章ではうまく動きません。そこでサンプルコードでは正規表現ベースの軽量トークナイザ (`tokenize_for_bm25`) を用意し、`BM25Retriever.from_documents(..., preprocess_func=...)` に渡しています。

この 1 行を挟むだけで、文書とクエリの両方が同じルールで前処理され、「Elasticsearchの監視設定」のような固有名詞クエリでも BM25 が機能します。より精度を高めたい場合は、`tokenize_for_bm25` の中身を MeCab や SudachiPy を使った関数に差し替えることもできます。

## 5.5.3 重み付けパラメータを調整する

さらに興味深いのは、重み付け（weights）を変えることでの動作の変化です。「RAGを最適化するにはDense Retrievalをどう使う？」というクエリで見ていきましょう。

=== 重み付けの影響の確認 ===  
クエリ：「RAGを最適化するにはDense Retrievalをどう使う？」

上位3件の結果：

1. hybrid_doc_05.txt  
2. hybrid_doc_03.txt  
3. hybrid_doc_02.txt

ベースとなるランキングは同じ RRF アルゴリズムでも、重み付けを変えるだけで 2 位・3 位の顔ぶれが入れ替わることがあります。運用では「固有名詞の取りこぼしを防ぎたい」「意味的な広がりを重視したい」といったニーズに合わせて重みを調整するのがポイントです。

## 5.5.4 実装のポイント

- 用途に応じた重み調整：技術文書なら BM25 を重視、FAQ ならベクトル検索を重視など、データの性質に応じて weights パラメータを調整することが重要です。
- RRF の k パラメータ：デフォルトの 60 は多くの場合うまく機能しますが、検索結果の数が少ない場合は調整が必要かもしれません。
- 検索数の設定：各 Retriever の top_k パラメータ（取得数）は最終的に必要な数より多めに設定し、RRF で統合後に絞り込むのが効果的です。

これで、キーワード検索の精度とベクトル検索の柔軟性を併せ持つ、頑健な RAG システムの検索部分が完成しました。
