# 5.5 ハイブリッド検索を実装する

ここまででベクトル検索による RAG が実現できました。次に先ほど学んだハイブリッド検索を実装しましょう。

## 5.5.1 EnsembleRetriever で統合する

実際にハイブリッド検索を実装してみましょう。LangChain の EnsembleRetriever（アンサンブルレトリーバー）を使えば、RRF（スコアリング）の計算も自動でやってくれます。プログラムは `scripts/chapter5/5-5-1-hybrid-search-rrf.py` を参照してください（サンプル文書は `scripts/chapter5/hybrid_sample_data/*.txt` を使用）。

### ソースコード（抜粋）

以下は `scripts/chapter5/5-5-1-hybrid-search-rrf.py` の主要部分のみを抜粋しています（インポートや .env 読み込み、結果保存などは省略）。全文はスクリプトを参照してください。

```python
def load_documents_from_files() -> List[Document]:
    """hybrid_sample_data/ディレクトリからドキュメントを読み込み"""
    current_dir = Path(__file__).parent
    data_dir = current_dir / "hybrid_sample_data"

    if not data_dir.exists():
        raise FileNotFoundError(f"データディレクトリが見つかりません: {data_dir}")

    documents = []

    # .txtファイルを番号順にソート
    txt_files = sorted(data_dir.glob("hybrid_doc_*.txt"))

    for i, file_path in enumerate(txt_files):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()

            document = Document(
                page_content=content,
                metadata={
                    "source": file_path.name,
                    "id": i + 1,
                    "file_path": str(file_path)
                }
            )
            documents.append(document)

        except Exception as e:
            print(f"ファイル読み込みエラー {file_path}: {e}")
            continue

    if not documents:
        raise ValueError("読み込めるドキュメントファイルがありません")

    return documents


def tokenize_for_bm25(text: str) -> list[str]:
    """
    日本語を含むテキストを軽量にトークナイズする。
    - 英数字はそのまま1トークン。
    - 漢字・ひらがな・カタカナの連続部分は文字bi-gramに分解し、部分一致しやすくする。
    """
    tokens: list[str] = []
    for chunk in re.findall(r"[A-Za-z0-9]+|[一-龥ぁ-んァ-ンー]+", text):
        if re.fullmatch(r"[A-Za-z0-9]+", chunk):
            tokens.append(chunk)
        else:
            # 日本語部分は bi-gram で分割して BM25 のヒット率を上げる
            if len(chunk) == 1:
                tokens.append(chunk)
            else:
                tokens.extend(chunk[i: i + 2] for i in range(len(chunk) - 1))
    return tokens

def compare_retrieval_methods(splits: List[Document]):
    """検索手法の比較デモ"""

    output = []
    output.append("\n=== 検索手法の比較 ===\n")
    print(output[-1])

    # 1. BM25 Retrieverの構築
    bm25_retriever = BM25Retriever.from_documents(
        splits,
        preprocess_func=tokenize_for_bm25,
    )
    bm25_retriever.k = 3

    # 2. ベクトル検索 Retrieverの構築
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(
        documents=splits,
        embedding=embeddings,
        collection_name="hybrid_demo"
    )
    dense_retriever = vectorstore.as_retriever(search_kwargs={"k": 3})

    # テストクエリ
    queries = [
        "X-Pack monitoring の設定方法",                    # 固有名詞・製品名でBM25が有利
        "セマンティック検索のメリット",                       # 抽象表現でベクトルが有利
    ]

    for query in queries:
        output.append(f"クエリ: '{query}'")
        output.append("=" * 60)
        print(f"クエリ: '{query}'")
        print("=" * 60)

        # BM25検索
        output.append("\n【BM25検索結果】")
        print("\n【BM25検索結果】")
        bm25_results = bm25_retriever.invoke(query)
        for i, doc in enumerate(bm25_results):
            title = doc.page_content.splitlines()[0]
            output.append(f"  {i+1}. {doc.metadata['source']}: {title}")
            print(f"  {i+1}. {doc.metadata['source']}: {title}")

        # ベクトル検索
        output.append("\n【ベクトル検索結果】")
        print("\n【ベクトル検索結果】")
        vector_results = dense_retriever.invoke(query)
        for i, doc in enumerate(vector_results):
            title = doc.page_content.splitlines()[0]
            output.append(f"  {i+1}. {doc.metadata['source']}: {title}")
            print(f"  {i+1}. {doc.metadata['source']}: {title}")

        output.append("\n" + "-" * 60 + "\n")
        print("\n" + "-" * 60 + "\n")

    save_result("5-4-1-hybrid-search-comparison.txt", "\n".join(output))

    # クリーンアップ
    vectorstore.delete_collection()


def demonstrate_ensemble_retriever(splits: List[Document]):
    """EnsembleRetrieverのデモンストレーション"""

    output = []
    output.append("\n=== EnsembleRetriever（ハイブリッド検索）のデモ ===\n")
    print(output[-1])

    # BM25 Retrieverの構築
    bm25_retriever = BM25Retriever.from_documents(
        splits,
        preprocess_func=tokenize_for_bm25,
    )
    bm25_retriever.k = 12  # 多めに候補を取得

    # ベクトル検索 Retrieverの構築
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(
        documents=splits,
        embedding=embeddings,
        collection_name="ensemble_demo"
    )
    dense_retriever = vectorstore.as_retriever(search_kwargs={"k": 6})

    # EnsembleRetrieverでハイブリッド検索を構築（内部でRRF）
    # weights: 各Retrieverの重み付け（合計1でなくてよい）
    hybrid_retriever = EnsembleRetriever(
        retrievers=[bm25_retriever, dense_retriever],
        weights=[0.6, 1.0],  # BM25を少し抑えめ、ベクトルを重視
        c=60,               # RRFのk（高順位をどれだけ強調するか）
    )

    # テストクエリ（ハイブリッドデモ用）
    test_queries = [
        "X-Pack monitoring の設定方法",
        "セマンティック検索のメリット",
    ]

    for query in test_queries:
        output.append(f"クエリ: '{query}'")
        output.append("-" * 50)
        print(f"クエリ: '{query}'")
        print("-" * 50)

        # ハイブリッド検索の実行
        results = hybrid_retriever.invoke(query)

        # 上位4件を表示（ファイル名＋タイトル）
        output.append("ハイブリッド検索結果（上位4件）:")
        print("ハイブリッド検索結果（上位4件）:")
        for i, doc in enumerate(results[:4]):
            source = doc.metadata.get('source', 'unknown')
            title = doc.page_content.splitlines()[0]
            output.append(f"  【結果{i+1}】{source}: {title}")
            print(f"  【結果{i+1}】{source}: {title}")

        output.append("")
        print()

    save_result("5-4-1-ensemble-results.txt", "\n".join(output))

    # 重み付けの影響を確認（1クエリで1位が入れ替わる例）
    output2 = []
    output2.append("\n=== 重み付けの影響の確認 ===\n")
    print(output2[-1])

    weight_configs = [
        (0.9, 0.1, "BM25重視"),
        (0.5, 0.5, "均等"),
        (0.1, 0.9, "ベクトル重視"),
    ]

    query = "セマンティック検索のメリット"  # 重みで1位が揺れやすいクエリ

    for bm25_w, vec_w, desc in weight_configs:
        output2.append(f"\n設定: {desc} (BM25={bm25_w}, Vector={vec_w})")
        output2.append("-" * 40)
        print(f"\n設定: {desc} (BM25={bm25_w}, Vector={vec_w})")
        print("-" * 40)

        # 異なる重み付けでEnsembleRetrieverを構築
        weighted_hybrid = EnsembleRetriever(
            retrievers=[bm25_retriever, dense_retriever],
            weights=[bm25_w, vec_w],
            c=60,
        )

        results = weighted_hybrid.invoke(query)
        output2.append("上位3件の結果:")
        print("上位3件の結果:")
        for i, doc in enumerate(results[:3]):
            output2.append(f"  {i+1}. {doc.metadata['source']}")
            print(f"  {i+1}. {doc.metadata['source']}")

    save_result("5-4-1-weight-comparison.txt", "\n".join(output2))

    # クリーンアップ
    vectorstore.delete_collection()


def main():
    """メインの実行関数"""
    # .envファイルから環境変数を読み込み
    load_dotenv()

    # サンプル文書の読み込み
    documents = load_documents_from_files()
    print(f"サンプル文書を{len(documents)}件読み込みました。")

    # テキストの分割
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=800,
        chunk_overlap=160,
        separators=["\n\n", "\n", "。", "、", " ", ""]
    )
    splits = text_splitter.split_documents(documents)
    print(f"文書を{len(splits)}個のチャンクに分割しました。")

    # 検索手法の比較
    compare_retrieval_methods(splits)

    # EnsembleRetrieverのデモ
    demonstrate_ensemble_retriever(splits)

    print("\n✓ ハイブリッド検索デモが完了しました。")


if __name__ == "__main__":
    main()

```

EnsembleRetriever はそのまま LCEL パイプライン（「4 章 4.3.4Chain」参照）の Retriever として使用できるため、既存の RAG システムに簡単に組み込むことができます。

## 5.5.2 検索結果を比較分析する

まず、それぞれの検索手法の比較結果を見てみましょう。

**クエリ：『X-Pack monitoring の設定方法』**

=== 検索手法の比較 ===

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装　 → 製品名「X-Pack monitoring」で BM25 が圧倒
2. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略
3. hybrid_doc_06.txt：LangChain の EnsembleRetriever による統合検索

ベクトル検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装　 → 固有名詞が効きベクトルでも 1 位
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_01.txt：BM25 アルゴリズムの実装詳細

固有名詞を含む具体クエリでは BM25 が強みを発揮します。ベクトル検索でも 1 位は同じ文書になりますが、2〜3 位が一般論（doc04/01）に流れやすく、順位差で性質の違いが見えます。

**クエリ：『セマンティック検索のメリット』**

BM25 検索結果

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

ベクトル検索結果

1. hybrid_doc_03.txt：検索技術の進化と意味理解の革命　 → 意味検索の意義を直接説明
2. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

カタカナの「セマンティック」はコーパス内に明示されないため、BM25 は汎用的な「検索」語を多く含む doc02 に流れがち。一方ベクトル検索は意味類似で doc03（意味検索の解説）を 1 位に引き上げ、ベクトル優位な例となります。

では EnsembleRetriever でこれらを統合した結果を見てみましょう。

=== EnsembleRetriever（ハイブリッド検索）のデモ（実行結果） ===

クエリ：『X-Pack monitoring の設定方法』

ハイブリッド検索結果（上位 4 件）:

1. hybrid_doc_02.txt: Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt: 開発者の生産性向上と創造的業務への集中
3. hybrid_doc_05.txt: RAG システムの最適化手法と実装戦略
4. hybrid_doc_01.txt: BM25 アルゴリズムの実装詳細

クエリ：『セマンティック検索のメリット』

ハイブリッド検索結果（上位 4 件）:

1. hybrid_doc_02.txt: Elasticsearch による高性能検索システムの実装
2. hybrid_doc_03.txt: 検索技術の進化と意味理解の革命
3. hybrid_doc_05.txt: RAG システムの最適化手法と実装戦略
4. hybrid_doc_04.txt: 開発者の生産性向上と創造的業務への集中

両方の検索手法で上位にランクされた文書が、RRF によって総合的に高いスコアを得ています。これが「それぞれの意見を聞く」ハイブリッド検索の強みです。

## コラム：BM25 検索を日本語で扱う Tips

LangChain の BM25Retriever は標準だと `text.split()` で語を切り出すため、日本語のように空白が入らない文章ではうまく動きません。そこでサンプルコードでは正規表現ベースの軽量トークナイザ (`tokenize_for_bm25`) を用意し、`BM25Retriever.from_documents(..., preprocess_func=...)` に渡しています。

この 1 行を挟むだけで、文書とクエリの両方が同じルールで前処理され、「Elasticsearch の監視設定」のような固有名詞クエリでも BM25 が機能します。より精度を高めたい場合は、`tokenize_for_bm25` の中身を MeCab や SudachiPy を使った関数に差し替えることもできます。

## 5.5.3 重み付けパラメータを調整する

さらに興味深いのは、重み付け（weights）を変えることでの動作の変化です。「セマンティック検索のメリット」というクエリで見ていきましょう。

=== 重み付けの影響の確認 ===  
クエリ：「セマンティック検索のメリット」

上位 3 件の結果：

設定: BM25 重視 (BM25=0.9, Vector=0.1)

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

設定: 均等 (BM25=0.5, Vector=0.5)

1. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
2. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
3. hybrid_doc_04.txt：開発者の生産性向上と創造的業務への集中

設定: ベクトル重視 (BM25=0.1, Vector=0.9)

1. hybrid_doc_03.txt：検索技術の進化と意味理解の革命
2. hybrid_doc_02.txt：Elasticsearch による高性能検索システムの実装
3. hybrid_doc_05.txt：RAG システムの最適化手法と実装戦略

1 位が BM25 重視では doc02、ベクトル重視では doc03 に入れ替わり、weights パラメータで主役が切り替わる様子が分かります。均等設定では両者の中間として doc02 がわずかに上位を保ちつつ doc03 が 2 位に躍り出ます。

## 5.5.4 実装のポイント

- 用途に応じた重み調整：技術文書なら BM25 を重視、FAQ ならベクトル検索を重視など、データの性質に応じて weights パラメータを調整することが重要です。
- RRF の k パラメータ：デフォルトの 60 は多くの場合うまく機能しますが、検索結果の数が少ない場合は調整が必要かもしれません。
- 検索数の設定：各 Retriever の top_k パラメータ（取得数）は最終的に必要な数より多めに設定し、RRF で統合後に絞り込むのが効果的です。

これで、キーワード検索の精度とベクトル検索の柔軟性を併せ持つ、頑健な RAG システムの検索部分が完成しました。
